#!/usr/bin/python3
#
# Copyright (C) 2019 Nicolas Schodet
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#
import argparse
import configparser
import os
import subprocess
import sys

import tmdbsimple as tmdb

CONFIG = '~/.tmdblookup.conf'

class App:
    """Quick lookup on TheMovieDB."""

    def run(self, args):
        defaults = {}
        # Parse configuration.
        config = configparser.ConfigParser()
        config.read([os.path.expanduser(CONFIG)])
        defaults.update(dict(config.items('DEFAULT')))
        # Parse options.
        p = argparse.ArgumentParser(description=self.__doc__)
        p.set_defaults(**defaults)
        p.add_argument('--api-key',
                help='API key created in your account')
        p.add_argument('-l', '--language',
                help='content language')
        p.add_argument('-t', '--tv', action='store_true',
                help='search TV show')
        p.add_argument('-i', '--show-id', action='store_true',
                help='show identifier')
        p.add_argument('-s', '--season', type=int,
                help='print the list of episodes for a TV show season')
        p.add_argument('-a', '--all-seasons', action='store_true',
                help='print the list of all episodes for a TV show')
        p.add_argument('query', nargs='+', help='query terms or identifier')
        options = p.parse_args()
        if options.api_key is None:
            p.error('need an API key')
        tmdb.API_KEY = options.api_key
        query = ' '.join(options.query)
        if options.season is not None or options.all_seasons:
            try:
                i = int(query)
            except ValueError:
                i, l = self.get_id(query, options)
                print(l)
            self.show_season(i, options)
        else:
            results = self.search(query, options)
            for i, l in results.items():
                if options.show_id:
                    print(i, l)
                else:
                    print(l)

    def search(self, query, options):
        """Perform a TV show or movie search."""
        search = tmdb.Search()
        searchf = search.tv if options.tv else search.movie
        searchd = dict(query=query)
        if options.language:
            searchd['language'] = options.language
        searchf(**searchd)
        results = {}
        for r in search.results:
            y = None
            if options.tv:
                name = r['name']
                try:
                    y = r['first_air_date']
                except KeyError:
                    pass
            else:
                name = r['title']
                try:
                    y = r['release_date']
                except KeyError:
                    pass
            l = []
            l.append(name)
            if y:
                y, _, _ = y.split('-')
                l.append('(%s)' % y)
            results[r['id']] = ' '.join(l)
        return results

    def select(self, results):
        """Select one of the results."""
        r = subprocess.run(['fzf', '--height=12', '--with-nth=2', '--delimiter=\t'],
                           input='\n'.join(f'{i}\t{l}' for i, l in results.items()),
                           stdout=subprocess.PIPE, text=True)
        if r.returncode != 0:
            raise RuntimeError("no selection done")
        else:
            return int(r.stdout.split(maxsplit=1)[0])

    def get_id(self, query, options):
        """Return a TV or movie identifier and name, ask the user if needed."""
        results = self.search(query, options)
        if len(results) == 0:
            raise RuntimeError("no result")
        elif len(results) == 1:
            for i, l in results.items():
                return i, l
        else:
            i = self.select(results)
            return i, results[i]

    def get_seasons(self, tv_id, options):
        """Get the list of seasons for a TV show."""
        if options.season is not None:
            return [options.season]
        else:
            tv = tmdb.TV(tv_id)
            infod = dict()
            if options.language:
                infod['language'] = options.language
            tv.info(**infod)
            return [s['season_number'] for s in tv.seasons]

    def show_season(self, tv_id, options):
        """Print the list of episodes for a TV show season."""
        for s in self.get_seasons(tv_id, options):
            season = tmdb.TV_Seasons(tv_id, s)
            infod = dict()
            if options.language:
                infod['language'] = options.language
            season.info(**infod)
            for e in season.episodes:
                print('%dx%02d %s' % (season.season_number, e['episode_number'],
                    e['name']))

if __name__ == '__main__':
    import sys
    a = App()
    try:
        a.run(sys.argv[1:])
    except RuntimeError as e:
        sys.exit(str(e))
